JINY KERNEL 0.1  (JINY :  Jana's tINY)

1) WHAT IS JINY?.
 Jiny is a small foot print kernel, initally will be running on a virtual environment and with limited functionality on a baremetal. It is designed to run efficently with small foot print on a virtual environment.

2) ON WHAT HARDWARE DOES IT RUN?
 It will be fully tested for x86-64. partially done for x86-32 but discontinued.

3) For What purpose JINY will be used initially?
 JINY will be used initially to model the page cache suitable for hadoop like applications.

------------------------------------------

The goals of the project are:
	1) It should be monalitic kernel with a small footprint.
	2) To keep kernel size small. This is done by writing paravirtualised drivers  if it not running on the bare metal. To begin with, file system is implemented  with a paravirtualised driver.
	3) powerful command line and debug environment.
	4) Higly modularise:  To define well defined interface between modules , so as any module can be replaced by keeping the interface same. (see include/interface.h for more details.
------------------------------------------
page cache Modeling:
	page : Every page containg age entry, age is updated when ever the page is accessed or dirted.
	1) when page is read,
				 if it MRU type the age is changed to eldest and moved to end of inactive list if it is in active list,
				 if it is LRU it is changed to youngest and moved to front of acive list.
	2)  when page is written,
	LRU dirty :
	MRU dirty :
	house keeper thread :1) It scans the pages periodically and updates the age.
			     2) It scan active , inactive list . based on the age,type of page(MRU or LRU) it alter the list.
------------------------------------------	
Design :
mm : memory management
pc : page cache 
vfs : virtual filesystem
kernel : cpu scheduling
--------------------------------------------
Code Organization:
  Entire code is splitted into the following modules:

1) scheduling (sc)
	sc_fork
	sc_createThread
	sc_exit
	sc_schedule
	
2) memory management ( vm,mm)
	vm_brk
	vm_mmap
	vm_munmap
	vm_findVma
	vm_printMmaps

	mm_getFreePages	
	mm_putFreePages	
	mm_malloc
	mm_free
	mm_kmem_*
	
3) VFS 
    pagecache:
	pc_getInodePage : get particular page of offset from inode
	pc_insertInodePage : insert a page in to inode or pagecache
	pc_putFreePage : put a page into free list
	pc_getFreePage : get a free page from free list
	pc_init : initialize the subsystem	

	fs_getInode : from filename get the appropriate inode
	fs_registerFileSystem :
	fs_open,fs_read,fs_write,fs_close  : file operations
	
4) isr  (AR)
5) Drivers (DR)
6) utilities (UT)
	ut_putchar
	ut_printf
	ut_memcpy
	ut_memset
	ut_strcmp
	ut_strcpy
	ut_strlen

_____________________________
 Running :
  -> multiboot (hd0)/kernel
  -> boot

vim commands:
    ESC V G =   for entire file
    ESC V % =  for a block
  V= visual mode
------------------------------
Constructing the image for grub2 (Not sucessfull):

dd if=/dev/zero of=bin/g2_image bs=512 count=8000
--sudo losetup /dev/loop0 -d
--sudo losetup /dev/loop0  bin/g2_image
--sudo mke2fs /dev/loop0
mke2fs bin/g2_image
sudo mount /dev/loop0 /tmp/ab/
populate files into /tmp/ab/

sudo umount /tmp/ab
sudo grub-install --force  /dev/loop0 
-------------------------------
WorkAround:
    - use old image as bootable disk for grub, use second disk to store the kernel.
-----------------------------------
qemu running:
 sudo ./qemu-system-x86_64 -s -m 1024M -L /home/njana/qemu/opt/qemu.12.5/share/qemu -hda /home/njana/tinykernel/bin/g2_bootdisk -hdb /home/njana/tinykernel/bin/g2_image  -enable-kvm -chardev socket,path=/tmp/jana,id=jana -device ivshmem,chardev=jana,size=2m,msi=off -vnc :4
 
serial :
  -serial /dev/pt/1 

where /dev/pts/1 is the pty for the console running qemu

-------------------------------------
